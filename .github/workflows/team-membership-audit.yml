name: Team Membership Audit (org-wide, Node-only)

on:
  workflow_dispatch:
    inputs:
      org:
        description: "Org to scan (defaults to current repo owner)"
        required: false
      min_teams:
        description: "Minimum number of teams each user must be in"
        required: false
        default: "1"
      required_team_regex:
        description: "Optional regex; at least one team must match (e.g., ^(Contributors|Maintainers)$)"
        required: false
        default: ""
      include_outside_collaborators:
        description: "Also audit outside collaborators"
        required: false
        default: "true"
      skip_org_admins:
        description: "Skip users with org admin/owner role"
        required: false
        default: "true"
      exclude_users_csv:
        description: "Comma-separated logins to exclude (e.g., bot-1,octocat)"
        required: false
        default: ""
  # Uncomment to run weekly (Mondays 09:00 UTC)
  # schedule:
  #   - cron: "0 9 * * 1"

permissions:
  contents: read

jobs:
  audit:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.ORG_READ_TOKEN || secrets.GITHUB_TOKEN }}
      ORG_INPUT: ${{ github.event.inputs.org }}
      MIN_TEAMS: ${{ github.event.inputs.min_teams }}
      REQUIRED_TEAM_REGEX: ${{ github.event.inputs.required_team_regex }}
      INCLUDE_OUTSIDERS: ${{ github.event.inputs.include_outside_collaborators }}
      SKIP_ADMINS: ${{ github.event.inputs.skip_org_admins }}
      EXCLUDE_USERS_CSV: ${{ github.event.inputs.exclude_users_csv }}

    steps:
      - name: Resolve org
        id: ctx
        run: |
          if [ -n "$ORG_INPUT" ]; then ORG="$ORG_INPUT"; else ORG="${{ github.repository_owner }}"; fi
          echo "org=$ORG" >> $GITHUB_OUTPUT
          echo "Scanning org: $ORG"

      - name: Team membership audit + outputs (JSON/CSV) + summary
        id: audit_and_summarize
        uses: actions/github-script@v7
        env:
          ORG: ${{ steps.ctx.outputs.org }}
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const fs = require('fs');

            // ---------- Inputs ----------
            const org = process.env.ORG;
            const minTeams = parseInt(process.env.MIN_TEAMS || "1", 10);
            const requiredReStr = (process.env.REQUIRED_TEAM_REGEX || "").trim();
            let includeOutsiders = (process.env.INCLUDE_OUTSIDERS || "true").toLowerCase() === "true";
            const skipAdmins = (process.env.SKIP_ADMINS || "true").toLowerCase() === "true";
            const excludeSet = new Set(
              (process.env.EXCLUDE_USERS_CSV || "")
                .split(",").map(s => s.trim().toLowerCase()).filter(Boolean)
            );
            const reqTeam = requiredReStr ? new RegExp(requiredReStr, "i") : null;

            // ---------- Helpers ----------
            async function p(route, params) {
              return await github.paginate(route, { per_page: 100, ...params });
            }

            // ---------- Population ----------
            // Members
            const members = await p("GET /orgs/{org}/members", { org });

            // Outside collaborators
            let outsiders = [];
            if (includeOutsiders) {
              try {
                outsiders = await p("GET /orgs/{org}/outside_collaborators", { org });
              } catch (e) {
                core.warning(`Cannot list outside collaborators (${e.status || 'ERR'}): ${e.message}. Skipping outsiders.`);
                includeOutsiders = false;
              }
            }

            // Teams and membership
            const teams = await p("GET /orgs/{org}/teams", { org });
            const teamMembersMap = new Map(); // slug -> Set(login)
            for (const t of teams) {
              try {
                const tMembers = await p("GET /orgs/{org}/teams/{team_slug}/members", { org, team_slug: t.slug });
                teamMembersMap.set(t.slug, new Set(tMembers.map(u => u.login.toLowerCase())));
              } catch (e) {
                core.warning(`Cannot list members for team ${t.slug}: ${e.message}`);
                teamMembersMap.set(t.slug, new Set());
              }
            }

            const userTeamsMap = new Map(); // login -> [{slug,name}]
            function addTeamToUser(login, team) {
              const k = login.toLowerCase();
              const arr = userTeamsMap.get(k) || [];
              arr.push({ slug: team.slug, name: team.name });
              userTeamsMap.set(k, arr);
            }
            for (const t of teams) {
              for (const login of (teamMembersMap.get(t.slug) || new Set())) {
                addTeamToUser(login, { slug: t.slug, name: t.name });
              }
            }

            // Role cache
            const roleCache = new Map();
            async function getRole(login) {
              const k = login.toLowerCase();
              if (roleCache.has(k)) return roleCache.get(k);
              try {
                const { data } = await github.request("GET /orgs/{org}/memberships/{username}", { org, username: login });
                roleCache.set(k, data.role); // admin | member
                return data.role;
              } catch {
                roleCache.set(k, "member");
                return "member";
              }
            }

            // Build audited population: members + (optional) outsiders, de-duped
            const population = [
              ...members.map(u => ({ login: u.login, type: "member" })),
              ...(includeOutsiders ? outsiders.map(u => ({ login: u.login, type: "outside_collaborator" })) : [])
            ];
            const seen = new Map();
            for (const p_ of population) {
              const k = p_.login.toLowerCase();
              if (!seen.has(k)) seen.set(k, p_);
              else if (seen.get(k).type !== "member" && p_.type === "member") seen.set(k, p_);
            }

            // Evaluate policy
            const rows = [];
            for (const { login, type } of seen.values()) {
              if (excludeSet.has(login.toLowerCase())) continue;

              const role = await getRole(login);
              if (skipAdmins && role === "admin") continue;

              const teamsForUser = userTeamsMap.get(login.toLowerCase()) || [];
              const teamNames = teamsForUser.map(t => t.name);
              const teamSlugs = teamsForUser.map(t => t.slug);

              const hasMinTeams = teamsForUser.length >= (isNaN(minTeams) ? 1 : minTeams);
              const matchesRequired = reqTeam ? (teamNames.some(n => reqTeam.test(n)) || teamSlugs.some(s => reqTeam.test(s))) : true;

              const compliant = hasMinTeams && matchesRequired;
              const notes = [];
              if (!hasMinTeams) notes.push(`requires >=${minTeams} teams`);
              if (!matchesRequired && reqTeam) notes.push(`requires team matching /${requiredReStr}/`);

              rows.push({
                login,
                type,
                role,
                team_count: teamsForUser.length,
                teams: teamNames,
                compliant,
                notes: notes.join("; ")
              });
            }

            rows.sort((a,b) => (a.compliant === b.compliant) ? a.login.localeCompare(b.login) : (a.compliant ? 1 : -1));

            const generatedAt = new Date().toISOString().slice(0,10);
            const audit = {
              org,
              generated_at: generatedAt,
              policy: {
                min_teams: minTeams,
                required_team_regex: requiredReStr || null,
                include_outside_collaborators: includeOutsiders,
                skip_org_admins: skipAdmins
              },
              results: rows
            };

            // ---------- Write main audit JSON ----------
            fs.writeFileSync('team_membership_audit.json', JSON.stringify(audit, null, 2));

            // ---------- Build summary ----------
            const total = rows.length;
            const membersCount = rows.filter(r => r.type === 'member').length;
            const outsidersCount = rows.filter(r => r.type === 'outside_collaborator').length;
            const ok = rows.filter(r => r.compliant).length;
            const bad = total - ok;
            const pct = total ? Math.floor((ok * 100) / total) : 0;

            const teamCounts = rows.map(r => r.team_count || 0).sort((a,b)=>a-b);
            const minTC = teamCounts[0] ?? 0;
            const maxTC = teamCounts[teamCounts.length-1] ?? 0;
            const avgTC = total ? Math.floor((teamCounts.reduce((s,n)=>s+n,0) / total) * 100) / 100 : 0;
            const medianTC = total ? ((teamCounts[Math.floor((total-1)/2)] + teamCounts[Math.floor(total/2)]) / 2) : 0;

            const belowMin = rows.filter(r => (r.team_count || 0) < (audit.policy.min_teams ?? 1)).length;
            const reqRe = audit.policy.required_team_regex ? new RegExp(audit.policy.required_team_regex, 'i') : null;
            const missingRequired = reqRe ? rows.filter(r => !(r.teams || []).some(t => reqRe.test(t))).length : 0;

            // Per-team coverage CSV source
            const perTeam = {};
            for (const r of rows) for (const t of (r.teams || [])) perTeam[t] = (perTeam[t] || 0) + 1;

            // Write summary JSON
            const summary = {
              org,
              generated_at: generatedAt,
              policy: audit.policy,
              totals: { audited: total, members: membersCount, outside_collaborators: outsidersCount },
              compliance: { compliant: ok, non_compliant: bad, pct_compliant: pct },
              gaps: { below_min_teams: belowMin, missing_required_team: missingRequired },
              team_count_stats: { min: minTC, max: maxTC, avg: avgTC, median: medianTC },
              per_team_coverage: Object.entries(perTeam).sort((a,b)=>b[1]-a[1]).map(([team, users])=>({team, users}))
            };
            fs.writeFileSync('audit_summary.json', JSON.stringify(summary, null, 2));

            // ---------- CSV writers ----------
            const esc = (s) => {
              if (s === null || s === undefined) return '';
              const str = String(s);
              return `"${str.replace(/"/g, '""')}"`;
            };

            // Main audit CSV
            const auditHeader = ['login','type','role','team_count','teams','compliant','notes'];
            const auditRows = [auditHeader.join(',')];
            for (const r of rows) {
              auditRows.push([
                esc(r.login),
                esc(r.type),
                esc(r.role),
                esc(r.team_count),
                esc((r.teams || []).join('; ')),
                esc(r.compliant ? 'true' : 'false'),
                esc(r.notes || '')
              ].join(','));
            }
            fs.writeFileSync('team_membership_audit.csv', auditRows.join('\n'));

            // Summary KV CSV
            const kv = [
              ['metric','value'],
              ['org', summary.org],
              ['generated_at', summary.generated_at],
              ['audited', summary.totals.audited],
              ['members', summary.totals.members],
              ['outside_collab', summary.totals.outside_collaborators],
              ['compliant', summary.compliance.compliant],
              ['non_compliant', summary.compliance.non_compliant],
              ['pct_compliant', summary.compliance.pct_compliant],
              ['below_min_teams', summary.gaps.below_min_teams],
              ['missing_required', summary.gaps.missing_required_team],
              ['team_count_min', summary.team_count_stats.min],
              ['team_count_max', summary.team_count_stats.max],
              ['team_count_avg', summary.team_count_stats.avg],
              ['team_count_median', summary.team_count_stats.median]
            ];
            fs.writeFileSync('audit_summary_kv.csv', kv.map(r => r.map(esc).join(',')).join('\n'));

            // Per-team coverage CSV
            const ptHeader = ['team','users'];
            const ptRows = [ptHeader.join(',')];
            for (const e of summary.per_team_coverage) ptRows.push([esc(e.team), esc(e.users)].join(','));
            fs.writeFileSync('per_team_coverage.csv', ptRows.join('\n'));

            // ---------- Summarize on run page ----------
            const md = `## Team Membership Audit — Summary

**Org:** \`${org}\` • **Generated:** \`${generatedAt}\`

| Metric | Value |
|---|---:|
| Audited users | ${summary.totals.audited} |
| Compliant | ${summary.compliance.compliant} |
| Non-compliant | ${summary.compliance.non_compliant} |
| % Compliant | ${summary.compliance.pct_compliant}% |
| Below min teams | ${summary.gaps.below_min_teams} |
| Missing required team | ${summary.gaps.missing_required_team} |

**Policy:** min teams = \`${audit.policy.min_teams}\`${audit.policy.required_team_regex ? ` • required team regex = \`/${audit.policy.required_team_regex}/\`` : ``}${audit.policy.include_outside_collaborators ? ` • including outside collaborators` : ` • excluding outside collaborators`}${audit.policy.skip_org_admins ? ` • skipping org admins` : ``}
`;
            try {
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, md);
            } catch (e) {
              core.warning(`Could not write run summary: ${e.message}`);
            }

            // Expose outputs for optional gating
            core.setOutput('audited', String(summary.totals.audited));
            core.setOutput('non_compliant', String(summary.compliance.non_compliant));

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: team-membership-audit-bundle
          path: |
            team_membership_audit.json
            team_membership_audit.csv
            audit_summary.json
            audit_summary_kv.csv
            per_team_coverage.csv

      # Optional: fail build if there are any non-compliant users
      # - name: Fail on non-compliance
      #   if: steps.audit_and_summarize.outputs.non_compliant != '0'
      #   run: |
      #     echo "Non-compliant users found."
      #     exit 1
